"""
This type stub file was generated by pyright.
"""

import enum
from dataclasses import dataclass
from typing import Any, Iterator, List, Optional, Tuple
from pyee.asyncio import AsyncIOEventEmitter
from .rtcdtlstransport import RTCDtlsTransport

logger = ...
COOKIE_LENGTH = ...
COOKIE_LIFETIME = ...
MAX_STREAMS = ...
USERDATA_MAX_LENGTH = ...
SCTP_CAUSE_INVALID_STREAM = ...
SCTP_CAUSE_STALE_COOKIE = ...
SCTP_DATA_LAST_FRAG = ...
SCTP_DATA_FIRST_FRAG = ...
SCTP_DATA_UNORDERED = ...
SCTP_MAX_ASSOCIATION_RETRANS = ...
SCTP_MAX_BURST = ...
SCTP_MAX_INIT_RETRANS = ...
SCTP_RTO_ALPHA = ...
SCTP_RTO_BETA = ...
SCTP_RTO_INITIAL = ...
SCTP_RTO_MIN = ...
SCTP_RTO_MAX = ...
SCTP_TSN_MODULO = ...
RECONFIG_MAX_STREAMS = ...
SCTP_STATE_COOKIE = ...
SCTP_STR_RESET_OUT_REQUEST = ...
SCTP_STR_RESET_RESPONSE = ...
SCTP_STR_RESET_ADD_OUT_STREAMS = ...
SCTP_SUPPORTED_CHUNK_EXT = ...
SCTP_PRSCTP_SUPPORTED = ...
DATA_CHANNEL_ACK = ...
DATA_CHANNEL_OPEN = ...
DATA_CHANNEL_RELIABLE = ...
DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT = ...
DATA_CHANNEL_PARTIAL_RELIABLE_TIMED = ...
DATA_CHANNEL_RELIABLE_UNORDERED = ...
DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT_UNORDERED = ...
DATA_CHANNEL_PARTIAL_RELIABLE_TIMED_UNORDERED = ...
WEBRTC_DCEP = ...
WEBRTC_STRING = ...
WEBRTC_BINARY = ...
WEBRTC_STRING_EMPTY = ...
WEBRTC_BINARY_EMPTY = ...
def chunk_type(chunk) -> str:
    ...

def decode_params(body: bytes) -> List[Tuple[int, bytes]]:
    ...

def encode_params(params: List[Tuple[int, bytes]]) -> bytes:
    ...

def padl(length: int) -> int:
    ...

def tsn_minus_one(a: int) -> int:
    ...

def tsn_plus_one(a: int) -> int:
    ...

class Chunk:
    type = ...
    def __init__(self, flags: int = ..., body: bytes = ...) -> None:
        ...
    
    def __bytes__(self) -> bytes:
        ...
    
    def __repr__(self) -> str:
        ...
    


class BaseParamsChunk(Chunk):
    def __init__(self, flags: int = ..., body: Optional[bytes] = ...) -> None:
        ...
    
    @property
    def body(self) -> bytes:
        ...
    


class AbortChunk(BaseParamsChunk):
    type = ...


class CookieAckChunk(Chunk):
    type = ...


class CookieEchoChunk(Chunk):
    type = ...


class DataChunk(Chunk):
    type = ...
    def __init__(self, flags: int = ..., body: Optional[bytes] = ...) -> None:
        ...
    
    def __bytes__(self) -> bytes:
        ...
    
    def __repr__(self) -> str:
        ...
    


class ErrorChunk(BaseParamsChunk):
    type = ...


class ForwardTsnChunk(Chunk):
    type = ...
    def __init__(self, flags: int = ..., body: Optional[bytes] = ...) -> None:
        ...
    
    @property
    def body(self) -> bytes:
        ...
    
    def __repr__(self) -> str:
        ...
    


class HeartbeatChunk(BaseParamsChunk):
    type = ...


class HeartbeatAckChunk(BaseParamsChunk):
    type = ...


class BaseInitChunk(Chunk):
    def __init__(self, flags: int = ..., body: Optional[bytes] = ...) -> None:
        ...
    
    @property
    def body(self) -> bytes:
        ...
    


class InitChunk(BaseInitChunk):
    type = ...


class InitAckChunk(BaseInitChunk):
    type = ...


class ReconfigChunk(BaseParamsChunk):
    type = ...


class SackChunk(Chunk):
    type = ...
    def __init__(self, flags=..., body=...) -> None:
        ...
    
    def __bytes__(self) -> bytes:
        ...
    
    def __repr__(self) -> str:
        ...
    


class ShutdownChunk(Chunk):
    type = ...
    def __init__(self, flags=..., body=...) -> None:
        ...
    
    @property
    def body(self) -> bytes:
        ...
    
    def __repr__(self) -> str:
        ...
    


class ShutdownAckChunk(Chunk):
    type = ...


class ShutdownCompleteChunk(Chunk):
    type = ...


CHUNK_CLASSES = ...
CHUNK_TYPES = ...
def parse_packet(data: bytes) -> Tuple[int, int, int, List[Any]]:
    ...

def serialize_packet(source_port: int, destination_port: int, verification_tag: int, chunk: Chunk) -> bytes:
    ...

@dataclass
class StreamResetOutgoingParam:
    request_sequence: int
    response_sequence: int
    last_tsn: int
    streams: List[bytes] = ...
    def __bytes__(self) -> bytes:
        ...
    
    @classmethod
    def parse(cls, data): # -> Self:
        ...
    


@dataclass
class StreamAddOutgoingParam:
    request_sequence: int
    new_streams: int
    def __bytes__(self) -> bytes:
        ...
    
    @classmethod
    def parse(cls, data): # -> Self:
        ...
    


@dataclass
class StreamResetResponseParam:
    response_sequence: int
    result: int
    def __bytes__(self) -> bytes:
        ...
    
    @classmethod
    def parse(cls, data): # -> Self:
        ...
    


RECONFIG_PARAM_TYPES = ...
class InboundStream:
    def __init__(self) -> None:
        ...
    
    def add_chunk(self, chunk: DataChunk) -> None:
        ...
    
    def pop_messages(self) -> Iterator[Tuple[int, int, bytes]]:
        ...
    
    def prune_chunks(self, tsn: int) -> int:
        """
        Prune chunks up to the given TSN.
        """
        ...
    


@dataclass
class RTCSctpCapabilities:
    """
    The :class:`RTCSctpCapabilities` dictionary provides information about the
    capabilities of the :class:`RTCSctpTransport`.
    """
    maxMessageSize: int
    ...


class RTCSctpTransport(AsyncIOEventEmitter):
    """
    The :class:`RTCSctpTransport` interface includes information relating to
    Stream Control Transmission Protocol (SCTP) transport.

    :param transport: An :class:`RTCDtlsTransport`.
    """
    def __init__(self, transport: RTCDtlsTransport, port: int = ...) -> None:
        ...
    
    @property
    def is_server(self) -> bool:
        ...
    
    @property
    def maxChannels(self) -> Optional[int]:
        """
        The maximum number of :class:`RTCDataChannel` that can be used simultaneously.
        """
        ...
    
    @property
    def port(self) -> int:
        """
        The local SCTP port number used for data channels.
        """
        ...
    
    @property
    def state(self) -> str:
        """
        The current state of the SCTP transport.
        """
        ...
    
    @property
    def transport(self): # -> RTCDtlsTransport:
        """
        The :class:`RTCDtlsTransport` over which SCTP data is transmitted.
        """
        ...
    
    @classmethod
    def getCapabilities(cls) -> RTCSctpCapabilities:
        """
        Retrieve the capabilities of the transport.

        :rtype: RTCSctpCapabilities
        """
        ...
    
    def setTransport(self, transport) -> None:
        ...
    
    async def start(self, remoteCaps: RTCSctpCapabilities, remotePort: int) -> None:
        """
        Start the transport.
        """
        ...
    
    async def stop(self) -> None:
        """
        Stop the transport.
        """
        ...
    
    class State(enum.Enum):
        CLOSED = ...
        COOKIE_WAIT = ...
        COOKIE_ECHOED = ...
        ESTABLISHED = ...
        SHUTDOWN_PENDING = ...
        SHUTDOWN_SENT = ...
        SHUTDOWN_RECEIVED = ...
        SHUTDOWN_ACK_SENT = ...
    
    


